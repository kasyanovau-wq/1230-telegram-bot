# -*- coding: utf-8 -*-
"""–ö–æ–ø–∏—è –±–ª–æ–∫–Ω–æ—Ç–∞ "app.py"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Br1KHaNsVETs8ZpGah8VmaHxrcgHt_Hi
"""

import os, json, threading, re
from datetime import datetime
from flask import Flask, request
from telegram import Update, KeyboardButton, ReplyKeyboardMarkup, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters

# ========= CONFIG =========
BOT_TOKEN = os.environ.get("BOT_TOKEN", "").strip()
WEBHOOK_SECRET = os.environ.get("WEBHOOK_SECRET", "").strip()  # optional: add ?secret=XYZ to webhook URL
ADMIN_USER_IDS = set([int(x) for x in os.environ.get("ADMIN_USER_IDS", "").split(",") if x.strip().isdigit()])

assert BOT_TOKEN, "BOT_TOKEN env var is required"

DATA_FILE = "data.json"   # lightweight persistence
LOCK = threading.Lock()   # to guard data file writes

# ========= DATA STORE =========
# Structure:
# {
#   "<identifier>": {  # email or phone
#       "chat_id": 123456789,
#       "items": { "<recordId>": {"name": "...", "status": "..."} },
#       "orders": { "<recordId>": {"item": "...", "status": "..."} }
#   },
#   ...
# }
data_store = {}

def load_data():
    global data_store
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            data_store = json.load(f)
    except FileNotFoundError:
        data_store = {}
    except Exception as e:
        print("Failed to load data.json:", e)
        data_store = {}

def save_data():
    with LOCK:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(data_store, f, ensure_ascii=False, indent=2)

load_data()

# ========= TELEGRAM BOT =========
app_tg = Application.builder().token(BOT_TOKEN).build()
bot = Bot(token=BOT_TOKEN)

WELCOME = (
    "Hi! üëã To find your items/orders, please *share your phone* or *type your email*.\n"
    "Then send /status anytime to get updates."
)

def html_escape(text: str) -> str:
    return (text or "").replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

def normalize_email(s: str) -> str:
    return (s or "").strip().lower()

def normalize_phone(s: str) -> str:
    s = (s or "").strip()
    # keep leading + and digits
    s = re.sub(r"[^\d+]", "", s)
    # ensure single leading +
    if s and s[0] != "+":
        # naive: assume international not guaranteed; keep as digits if no +
        pass
    return s

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    kb = [[KeyboardButton("üì± Share my phone", request_contact=True)]]
    await update.message.reply_text(
        WELCOME,
        reply_markup=ReplyKeyboardMarkup(kb, one_time_keyboard=True, resize_keyboard=True),
        parse_mode="Markdown"
    )

async def cmd_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Commands:\n"
        "/start ‚Äì link your phone/email\n"
        "/status ‚Äì show all your item & order statuses\n"
        "(Admins) /update_status <item|order> <recordId> <new status>"
    )

def link_chat(identifier: str, chat_id: int):
    if identifier not in data_store:
        data_store[identifier] = {"items": {}, "orders": {}}
    data_store[identifier]["chat_id"] = chat_id
    save_data()

def find_user_key_by_chat(chat_id: int):
    for key, payload in data_store.items():
        if payload.get("chat_id") == chat_id:
            return key
    return None

async def handle_contact(update: Update, context: ContextTypes.DEFAULT_TYPE):
    contact = update.message.contact
    phone = normalize_phone(contact.phone_number)
    link_chat(phone, update.effective_chat.id)
    await update.message.reply_text("‚úÖ Phone linked. Send /status to see updates.")

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # treat any non-command text as potential email
    text = (update.message.text or "").strip()
    if "@" in text and "." in text:
        email = normalize_email(text)
        link_chat(email, update.effective_chat.id)
        await update.message.reply_text(f"‚úÖ Email {email} linked. Send /status to see updates.")
    else:
        await update.message.reply_text(
            "Please send a valid email (like name@example.com) or tap the phone button via /start."
        )

def build_status_lines(info: dict):
    lines = []
    # Items (seller)
    items = (info or {}).get("items", {})
    for rec_id, rec in items.items():
        name = html_escape(rec.get("name") or f"Item {rec_id}")
        status = html_escape(rec.get("status") or "Unknown")
        lines.append(f"üì¶ <b>Item:</b> {name} ‚Äî <b>{status}</b>")
    # Orders (buyer)
    orders = (info or {}).get("orders", {})
    for rec_id, rec in orders.items():
        item_name = html_escape(rec.get("item") or f"Order {rec_id}")
        status = html_escape(rec.get("status") or "Unknown")
        lines.append(f"üõí <b>Order:</b> {item_name} ‚Äî <b>{status}</b>")
    return lines

async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user_key = find_user_key_by_chat(chat_id)
    if not user_key:
        await update.message.reply_text("I don‚Äôt know you yet. Use /start and share phone or type your email.")
        return
    info = data_store.get(user_key, {})
    lines = build_status_lines(info)
    if not lines:
        await update.message.reply_text("No items or orders found yet.")
    else:
        await update.message.reply_html("\n".join(lines))

async def cmd_update_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Admin only; format: /update_status <item|order> <recordId> <new status...>
    user_id = update.effective_user.id
    if user_id not in ADMIN_USER_IDS:
        return
    args = context.args
    if len(args) < 3:
        await update.message.reply_text("Usage: /update_status <item|order> <recordId> <new status text>")
        return
    kind, rec_id = args[0].lower(), args[1]
    new_status = " ".join(args[2:])
    # find rec in all users
    found = False
    for ident, bundle in data_store.items():
        if kind == "item" and rec_id in bundle.get("items", {}):
            bundle["items"][rec_id]["status"] = new_status
            save_data()
            found = True
            chat_id = bundle.get("chat_id")
            if chat_id:
                msg = f"üîî Update: Your item <b>{html_escape(bundle['items'][rec_id].get('name'))}</b> is now <b>{html_escape(new_status)}</b>."
                await app_tg.bot.send_message(chat_id, msg, parse_mode="HTML")
            break
        if kind == "order" and rec_id in bundle.get("orders", {}):
            bundle["orders"][rec_id]["status"] = new_status
            save_data()
            found = True
            chat_id = bundle.get("chat_id")
            if chat_id:
                msg = f"üîî Update: Your order <b>{html_escape(bundle['orders'][rec_id].get('item'))}</b> is now <b>{html_escape(new_status)}</b>."
                await app_tg.bot.send_message(chat_id, msg, parse_mode="HTML")
            break
    await update.message.reply_text("OK" if found else "Not found")

# Register handlers
app_tg.add_handler(CommandHandler("start", cmd_start))
app_tg.add_handler(CommandHandler("help", cmd_help))
app_tg.add_handler(CommandHandler("status", cmd_status))
app_tg.add_handler(CommandHandler("update_status", cmd_update_status))
app_tg.add_handler(MessageHandler(filters.CONTACT, handle_contact))
app_tg.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

# ========= FLASK (Tilda Webhook) =========
app = Flask(__name__)

def kv_find(data: dict, *needle_parts):
    """Find first key whose name contains all needle_parts (case-insensitive)."""
    for k in data.keys():
        name = k.lower()
        if all(part in name for part in needle_parts):
            return k
    return None

def upsert_record_from_tilda(payload: dict):
    """
    Heuristic parser:
    - identifier: email or phone
    - kind: item vs order guessed by presence of item/product vs order keywords
    - id: tranid or orderid or composed key
    """
    # choose identifier
    k_email = kv_find(payload, "email")
    k_phone = kv_find(payload, "phone")
    identifier = None
    if k_email and payload.get(k_email):
        identifier = normalize_email(payload.get(k_email))
    elif k_phone and payload.get(k_phone):
        identifier = normalize_phone(payload.get(k_phone))

    if not identifier:
        return None, None, None  # cannot link

    # detect status
    k_status = kv_find(payload, "status")
    status = (payload.get(k_status) if k_status else None) or "Submitted"

    # detect item/order naming
    k_item = kv_find(payload, "item") or kv_find(payload, "product")
    item_name = payload.get(k_item) if k_item else None

    k_orderid = kv_find(payload, "order")  # matches order/orderid
    order_id_val = payload.get(k_orderid) if k_orderid else None

    # Tilda tranid (lead id)
    tranid = payload.get("tranid") or payload.get("leadid") or payload.get("leads_id")

    # Decide kind
    kind = "item"
    if k_orderid and not k_item:
        kind = "order"

    # Record ID
    rec_id = (tranid or order_id_val or item_name or f"rec-{int(datetime.utcnow().timestamp())}")

    # Upsert
    bundle = data_store.setdefault(identifier, {"items": {}, "orders": {}})
    if kind == "item":
        rec = bundle["items"].setdefault(rec_id, {"name": item_name or f"Item {rec_id}", "status": "Submitted"})
        # update fields
        if item_name: rec["name"] = item_name
        if status: rec["status"] = status
    else:
        rec = bundle["orders"].setdefault(rec_id, {"item": item_name or f"Order {rec_id}", "status": "Placed"})
        if item_name: rec["item"] = item_name
        if status: rec["status"] = status

    save_data()
    return identifier, kind, rec_id

@app.route("/tilda_webhook", methods=["POST"])
def tilda_webhook():
    if WEBHOOK_SECRET:
        if request.args.get("secret") != WEBHOOK_SECRET:
            return "forbidden", 403

    # Accept both form-encoded and JSON
    data = {}
    try:
        if request.form:
            data = request.form.to_dict(flat=True)
        elif request.is_json:
            data = request.get_json(force=True) or {}
    except Exception:
        data = {}

    ident, kind, rec_id = upsert_record_from_tilda(data)

    # Notify user if we can
    if ident and rec_id:
        bundle = data_store.get(ident, {})
        chat_id = bundle.get("chat_id")
        if chat_id:
            if kind == "item":
                rec = bundle["items"][rec_id]
                msg = f"üîî Update: Your item <b>{html_escape(rec.get('name'))}</b> is now <b>{html_escape(rec.get('status'))}</b>."
            else:
                rec = bundle["orders"][rec_id]
                msg = f"üîî Update: Your order <b>{html_escape(rec.get('item'))}</b> is now <b>{html_escape(rec.get('status'))}</b>."
            try:
                bot.send_message(chat_id, msg, parse_mode="HTML")
            except Exception as e:
                print("send_message error:", e)

    return "ok"

# ========= RUN BOTH (Render expects web to bind PORT) =========
def run_bot():
    logger.info("Starting Telegram polling‚Ä¶")
    # IMPORTANT: disable signal handlers in a thread
    app_tg.run_polling(
        allowed_updates=Update.ALL_TYPES,
        stop_signals=None   # <-- this is the key
    )

@app.route("/", methods=["GET"])
def root():
    return "ok"

@app.route("/health", methods=["GET"])
def health():
    return "ok"

if __name__ == "__main__":
    # start bot in background
    threading.Thread(target=run_bot, daemon=True).start()

    port = int(os.environ.get("PORT", "5000"))
    app.run(host="0.0.0.0", port=port)
