# -*- coding: utf-8 -*-
"""–ö–æ–ø–∏—è –±–ª–æ–∫–Ω–æ—Ç–∞ "app.py"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Br1KHaNsVETs8ZpGah8VmaHxrcgHt_Hi
"""

# app.py ‚Äî hardened MVP (email-first, secure routes)
import os, re, json, csv, io, asyncio, logging, threading
from datetime import datetime
from flask import Flask, request

from telegram import Update, KeyboardButton, ReplyKeyboardMarkup, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters

# -------- config / env --------
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("1230")

BOT_TOKEN   = os.environ.get("BOT_TOKEN", "").strip()
AUTH_TOKEN  = os.environ.get("AUTH_TOKEN", "").strip()   # long random string
ADMIN_PATH  = os.environ.get("ADMIN_PATH", "").strip()   # long slug for admin route (e.g., ingest-7b6c3e)
PORT        = int(os.environ.get("PORT", "5000"))

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is required")
if not AUTH_TOKEN:
    raise RuntimeError("AUTH_TOKEN is required")
if not ADMIN_PATH:
    raise RuntimeError("ADMIN_PATH is required")

DATA_FILE = "data.json"
LOCK = threading.Lock()

WELCOME = (
    "Hi! üëã To find your items/orders, please *type your email* (recommended) or share your phone.\n"
    "Then send /status anytime to get updates."
)

# -------- storage --------
# { "<email|phone>": { "chat_id": 123, "items": {rec:{name,status}}, "orders": {rec:{item,status}} } }
data_store: dict = {}

def load_data():
    global data_store
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            data_store = json.load(f)
        if not isinstance(data_store, dict):
            data_store = {}
    except FileNotFoundError:
        data_store = {}
    except Exception as e:
        logger.warning("load_data error: %s", e); data_store = {}

def save_data():
    with LOCK:
        try:
            with open(DATA_FILE, "w", encoding="utf-8") as f:
                json.dump(data_store, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error("save_data error: %s", e)

load_data()

# -------- helpers --------
def html_escape(s: str | None) -> str:
    return (s or "").replace("&","&amp;").replace("<","&lt;").replace(">","&gt;")

def normalize_email(s: str | None) -> str:
    return (s or "").strip().lower()

def normalize_phone(s: str | None) -> str:
    s = (s or "").strip()
    digits = re.sub(r"[^\d+]", "", s)  # keep digits and leading +
    if digits.startswith("+"):
        return digits
    # RU-friendly heuristics
    if re.fullmatch(r"8\d{10}", digits):   # 8XXXXXXXXXX -> +7XXXXXXXXXX
        return "+7" + digits[1:]
    if re.fullmatch(r"7\d{10}", digits):   # 7XXXXXXXXXX -> +7XXXXXXXXXX
        return "+" + digits
    if re.fullmatch(r"9\d{9}", digits):    # 9XXXXXXXXX  -> +7XXXXXXXXXX
        return "+7" + digits
    return digits

def link_chat(identifier: str, chat_id: int):
    bundle = data_store.setdefault(identifier, {"items": {}, "orders": {}})
    bundle["chat_id"] = chat_id
    save_data()

def find_user_key_by_chat(chat_id: int):
    for k, v in data_store.items():
        if v.get("chat_id") == chat_id:
            return k
    return None

def build_status_lines(info: dict) -> list[str]:
    lines = []
    items = (info or {}).get("items", {})
    orders = (info or {}).get("orders", {})

    if items:
        lines.append("<b>üßæ Your selling items</b>")
        for rec_id, rec in items.items():
            name = html_escape(rec.get("name") or f"Item {rec_id}")
            status = html_escape(rec.get("status") or "Unknown")
            lines.append(f"‚Ä¢ {name} ‚Äî <b>{status}</b>")

    if orders:
        if lines:  # add a blank line between sections
            lines.append("")
        lines.append("<b>üõçÔ∏è Your orders</b>")
        for rec_id, rec in orders.items():
            item_name = html_escape(rec.get("item") or f"Order {rec_id}")
            status = html_escape(rec.get("status") or "Unknown")
            lines.append(f"‚Ä¢ {item_name} ‚Äî <b>{status}</b>")

    return lines

# -------- telegram (PTB v21) --------
app_tg = Application.builder().token(BOT_TOKEN).build()
bot    = Bot(token=BOT_TOKEN)

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    kb = [[KeyboardButton("üì± Share my phone", request_contact=True)]]
    await update.message.reply_text(
        WELCOME,
        reply_markup=ReplyKeyboardMarkup(kb, one_time_keyboard=True, resize_keyboard=True),
        parse_mode="Markdown"
    )

async def cmd_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Commands:\n"
        "/start ‚Äì link your email/phone\n"
        "/status ‚Äì show your item & order statuses"
    )

async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    key = find_user_key_by_chat(chat_id)
    if not key:
        await update.message.reply_text("I don‚Äôt know you yet. Type your email (or /start to share phone).")
        return
    lines = build_status_lines(data_store.get(key, {}))
    await (update.message.reply_html("\n".join(lines)) if lines else update.message.reply_text("No items or orders found yet."))

async def handle_contact(update: Update, context: ContextTypes.DEFAULT_TYPE):
    phone = normalize_phone(update.message.contact.phone_number)
    link_chat(phone, update.effective_chat.id)
    await update.message.reply_text("‚úÖ Phone linked. Send /status to see updates.")

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = (update.message.text or "").strip()
    if "@" in txt and "." in txt:
        email = normalize_email(txt)
        link_chat(email, update.effective_chat.id)
        await update.message.reply_text(f"‚úÖ Email {email} linked. Send /status to see updates.")
    else:
        await update.message.reply_text("Please send a valid email (like name@example.com) or use /start to share phone.")

# register handlers
app_tg.add_handler(CommandHandler("start", cmd_start))
app_tg.add_handler(CommandHandler("help",  cmd_help))
app_tg.add_handler(CommandHandler("status", cmd_status))
app_tg.add_handler(MessageHandler(filters.CONTACT, handle_contact))
app_tg.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

# -------- flask (web) --------
app = Flask(__name__)

@app.get("/")
def root():
    return "ok"

@app.get("/health")
def health():
    return "ok"

def kv_find(data: dict, *needles: str):
    for k in data.keys():
        name = k.lower()
        if all(n in name for n in needles):
            return k
    return None

def upsert_from_payload(payload: dict):
    # prefer email, then phone
    k_email = kv_find(payload, "email"); k_phone = kv_find(payload, "phone")
    ident = normalize_email(payload.get(k_email)) if (k_email and payload.get(k_email)) else \
            normalize_phone(payload.get(k_phone)) if (k_phone and payload.get(k_phone)) else None
    if not ident: return None, None, None

    k_status = kv_find(payload, "status")
    status = (payload.get(k_status) if k_status else None) or "Submitted"

    k_item   = kv_find(payload, "item") or kv_find(payload, "product")
    k_order  = kv_find(payload, "order")  # order / orderid
    item_name = payload.get(k_item) if k_item else None
    order_id  = payload.get(k_order) if k_order else None
    tranid    = payload.get("tranid") or payload.get("leadid") or payload.get("leads_id")

    kind = "item"
    if k_order and not k_item:
        kind = "order"

    rec_id = tranid or order_id or item_name or f"rec-{int(datetime.utcnow().timestamp())}"

    bundle = data_store.setdefault(ident, {"items": {}, "orders": {}})
    if kind == "item":
        rec = bundle["items"].setdefault(rec_id, {"name": item_name or f"Item {rec_id}", "status": "Submitted"})
        if item_name: rec["name"] = item_name
        rec["status"] = status
    else:
        rec = bundle["orders"].setdefault(rec_id, {"item": item_name or f"Order {rec_id}", "status": "Placed"})
        if item_name: rec["item"] = item_name
        rec["status"] = status
    save_data()
    return ident, kind, rec_id

# ---- Tilda webhook: secured by PATH token ----
# We register the route at /tilda_webhook/<AUTH_TOKEN> so there is no secret in query.
TILDA_PATH = f"/tilda_webhook/{AUTH_TOKEN}"

def tilda_webhook():
    # accept form or JSON
    payload = {}
    try:
        if request.form:
            payload = request.form.to_dict(flat=True)
        elif request.is_json:
            payload = request.get_json(force=True) or {}
    except Exception as e:
        logger.warning("tilda payload parse error: %s", e); payload = {}

    ident, kind, rec_id = upsert_from_payload(payload)
    if ident and kind and rec_id:
        bundle = data_store.get(ident, {})
        chat_id = bundle.get("chat_id")
        if chat_id:
            if kind == "item":
                rec = bundle["items"][rec_id]
                msg = f"üîî Update: Your item <b>{html_escape(rec.get('name'))}</b> is now <b>{html_escape(rec.get('status'))}</b>."
            else:
                rec = bundle["orders"][rec_id]
                msg = f"üîî Update: Your order <b>{html_escape(rec.get('item'))}</b> is now <b>{html_escape(rec.get('status'))}</b>."
            try:
                bot.send_message(chat_id, msg, parse_mode="HTML")
            except Exception as e:
                logger.error("send_message error: %s", e)
    return "ok"

# bind the path with token
app.add_url_rule(TILDA_PATH, view_func=tilda_webhook, methods=["POST"])

# ---- CSV import (admin) secured by path + Authorization header ----
CSV_EMAIL_KEYS   = ["email", "e-mail", "–ø–æ—á—Ç–∞"]
CSV_PHONE_KEYS   = ["phone", "—Ç–µ–ª–µ—Ñ–æ–Ω"]
CSV_STATUS_KEYS  = ["status", "—Å—Ç–∞—Ç—É—Å"]
CSV_ITEM_KEYS    = ["item", "product", "—Ç–æ–≤–∞—Ä", "–Ω–∞–∑–≤–∞–Ω–∏–µ", "–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ"]
CSV_ORDERID_KEYS = ["order", "orderid", "–∑–∞–∫–∞–∑", "id", "–Ω–æ–º–µ—Ä"]

def pick_key(row: dict, candidates: list[str]) -> str | None:
    lower = {k.lower(): k for k in row.keys()}
    for want in candidates:
        for lk, orig in lower.items():
            if want in lk:
                return orig
    return None

def check_auth_header(req) -> bool:
    return req.headers.get("Authorization", "") == f"Bearer {AUTH_TOKEN}"

def upsert_row(row: dict, kind: str, notify: bool):
    # ---------- identify the user (email first, then phone) ----------
    k_email = pick_key(row, CSV_EMAIL_KEYS)
    k_phone = pick_key(row, CSV_PHONE_KEYS)
    ident = None
    if k_email and row.get(k_email):
        ident = normalize_email(row[k_email])
    elif k_phone and row.get(k_phone):
        ident = normalize_phone(row[k_phone])
    if not ident:
        return  # can't link to a chat later without an identifier

    # ---------- find fields in this CSV row ----------
    k_status   = pick_key(row, CSV_STATUS_KEYS)  # common aliases like "status", "—Å—Ç–∞—Ç—É—Å"
    k_item     = pick_key(row, CSV_ITEM_KEYS)    # "item", "product", "—Ç–æ–≤–∞—Ä", ...
    k_orderid  = pick_key(row, CSV_ORDERID_KEYS) # "order", "orderid", "–∑–∞–∫–∞–∑", ...

    # Prefer human-readable Stage if present; otherwise fall back to status/statusid/etc.
    status = None
    for key in row.keys():
        lk = key.strip().lower()
        if lk == "stage":  # Tilda board column name (human text)
            status = (row[key] or "").strip()
            break
    if not status:
        status = (row.get(k_status) or "").strip() if k_status else ""
    if not status:
        # extra fallbacks that sometimes appear in Tilda exports
        status = (row.get("statusid") or row.get("pipeline") or row.get("pipeline_stage") or "").strip()
    if not status:
        status = "Submitted"

    # Item/Order display name:
    itemname = (row.get(k_item) or "").strip() if k_item else ""
    if not itemname:
        # Build from Brand + Size if present
        k_brand = pick_key(row, ["brand", "–±—Ä–µ–Ω–¥"])
        k_size  = pick_key(row, ["size", "—Ä–∞–∑–º–µ—Ä"])
        brand = (row.get(k_brand) or "").strip() if k_brand else ""
        size  = (row.get(k_size)  or "").strip() if k_size  else ""
        combo = " ".join([p for p in [brand, size] if p])
        itemname = combo if combo else None

    # Record ID: prefer explicit ids (tranid/order id), else item name, else timestamp
    tranid = (row.get("tranid") or row.get("leadid") or row.get("leads_id") or "").strip()
    order_id_val = (row.get(k_orderid) or "").strip() if k_orderid else ""
    rec_id = tranid or order_id_val or (itemname or "").strip() or f"rec-{int(datetime.utcnow().timestamp())}"

    # ---------- upsert into our store ----------
    bundle = data_store.setdefault(ident, {"items": {}, "orders": {}})
    if kind == "item":
        rec = bundle["items"].setdefault(rec_id, {"name": itemname or f"Item {rec_id}", "status": "Submitted"})
        if itemname:
            rec["name"] = itemname
        rec["status"] = status
    else:
        rec = bundle["orders"].setdefault(rec_id, {"item": itemname or f"Order {rec_id}", "status": "Placed"})
        if itemname:
            rec["item"] = itemname
        rec["status"] = status

    save_data()

    # ---------- optional notify ----------
    if notify and (chat_id := bundle.get("chat_id")):
        msg = (
            f"üîî Update: Your item <b>{html_escape(rec.get('name'))}</b> is now <b>{html_escape(status)}</b>."
            if kind == "item" else
            f"üîî Update: Your order <b>{html_escape(rec.get('item'))}</b> is now <b>{html_escape(status)}</b>."
        )
        try:
            bot.send_message(chat_id, msg, parse_mode="HTML")
        except Exception as e:
            logger.error("notify error: %s", e)

ADMIN_IMPORT_PATH = f"/admin/{ADMIN_PATH}/import_csv"

def admin_import_csv():
    if not check_auth_header(request):
        return "forbidden", 403
    kind = (request.args.get("type") or "").strip().lower()
    if kind not in {"item","order"}:
        return "bad type", 400

    # basic size guard (~10MB)
    if "file" not in request.files:
        return "no file", 400
    f = request.files["file"]
    f.seek(0, 2); size = f.tell(); f.seek(0)
    if size > 10 * 1024 * 1024:
        return "file too large", 413

    try:
        raw = f.read()
        # try common encodings (handles BOM & Cyrillic)
        text = None
        for enc in ("utf-8-sig", "utf-8", "cp1251", "windows-1251", "latin-1"):
            try:
                text = raw.decode(enc)
                break
            except Exception:
                continue
        if text is None:
            return "decode error", 415

        # Auto-detect delimiter (comma, semicolon, tab); fallback to ; then ,
        sample = text[:4096]
        try:
            dialect = csv.Sniffer().sniff(sample, delimiters=[",",";","\t"])
            reader = csv.DictReader(io.StringIO(text), dialect=dialect)
        except Exception:
            try:
                reader = csv.DictReader(io.StringIO(text), delimiter=";")
            except Exception:
                reader = csv.DictReader(io.StringIO(text), delimiter=",")

        count = 0
        for row in reader:
            # skip rows that are completely empty
            if not isinstance(row, dict) or not any((v or "").strip() for v in row.values()):
                continue
            upsert_row(row, kind, notify=False)
            count += 1
        return f"ok,{count}"
    except Exception as e:
        # temporary debug ‚Äî helps us see what's wrong if any
        return f"error: {type(e).__name__}: {e}", 500

app.add_url_rule(ADMIN_IMPORT_PATH, view_func=admin_import_csv, methods=["POST"])

# -------- run (Flask in thread, bot in main) --------
def run_flask():
    logger.info("Flask starting‚Ä¶")
    app.run(host="0.0.0.0", port=PORT)

if __name__ == "__main__":
    # Start Flask in background
    threading.Thread(target=run_flask, daemon=True).start()

    # Start Telegram polling in MAIN thread (no asyncio.run here)
    logger.info("Starting Telegram polling‚Ä¶")
    app_tg.run_polling(allowed_updates=Update.ALL_TYPES)