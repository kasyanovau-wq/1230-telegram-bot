# -*- coding: utf-8 -*-
"""–ö–æ–ø–∏—è –±–ª–æ–∫–Ω–æ—Ç–∞ "app.py"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Br1KHaNsVETs8ZpGah8VmaHxrcgHt_Hi
"""

# app.py ‚Äî hardened MVP (email-first, secure routes) + peek/search/alias
import os, re, json, csv, io, logging, threading
from datetime import datetime
from flask import Flask, request

from telegram import Update, KeyboardButton, ReplyKeyboardMarkup, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters

# -------- config / env --------
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("1230")

BOT_TOKEN   = os.environ.get("BOT_TOKEN", "").strip()
AUTH_TOKEN  = os.environ.get("AUTH_TOKEN", "").strip()   # long random string
ADMIN_PATH  = os.environ.get("ADMIN_PATH", "").strip()   # long slug for admin route (e.g., ingest-7b6c3e)
PORT        = int(os.environ.get("PORT", "5000"))

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is required")
if not AUTH_TOKEN:
    raise RuntimeError("AUTH_TOKEN is required")
if not ADMIN_PATH:
    raise RuntimeError("ADMIN_PATH is required")

# IMPORTANT: mount a Render disk at /data so this file persists across restarts
DATA_FILE = os.environ.get("DATA_FILE", "/data/data.json")

LOCK = threading.Lock()

WELCOME = (
    "Hi! üëã To find your items/orders, please *type your email* (recommended) or share your phone.\n"
    "Then send /status anytime to get updates."
)

# -------- storage --------
# { "<email|phone>": { "chat_id": 123, "items": {rec:{name,status}}, "orders": {rec:{item,status}} } }
data_store: dict = {}

def load_data():
    global data_store
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            data_store = json.load(f)
        if not isinstance(data_store, dict):
            data_store = {}
    except FileNotFoundError:
        data_store = {}
    except Exception as e:
        logger.warning("load_data error: %s", e); data_store = {}

def save_data():
    with LOCK:
        try:
            os.makedirs(os.path.dirname(DATA_FILE), exist_ok=True)
            with open(DATA_FILE, "w", encoding="utf-8") as f:
                json.dump(data_store, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error("save_data error: %s", e)

load_data()

# -------- helpers --------
def html_escape(s: str | None) -> str:
    return (s or "").replace("&","&amp;").replace("<","&lt;").replace(">","&gt;")

import re

EMAIL_RE = re.compile(r"^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$", re.I)
PHONE_RE_RAW = re.compile(r"^[+]?(\d[\s\-()]*){10,15}$")  # coarse: digits with optional + and separators

def is_email(s: str | None) -> bool:
    s = (s or "").strip()
    return bool(EMAIL_RE.match(s))

def is_phone(s: str | None) -> bool:
    s = (s or "").strip()
    if not PHONE_RE_RAW.match(s):
        return False
    # keep only digits and +
    digits = re.sub(r"[^\d+]", "", s)
    # Accept +7XXXXXXXXXX, 7XXXXXXXXXX, 8XXXXXXXXXX (RU)
    if digits.startswith("+7") and len(digits) == 12:
        return True
    if digits.startswith("7") and len(digits) == 11:
        return True
    if digits.startswith("8") and len(digits) == 11:
        return True
    return False

def normalize_email(s: str | None) -> str:
    return (s or "").strip().lower()

def normalize_phone(s: str | None) -> str:
    s = (s or "").strip()
    digits = re.sub(r"[^\d+]", "", s)
    # Normalize to +7XXXXXXXXXX
    if digits.startswith("+7") and len(digits) == 12:
        return digits
    if digits.startswith("7") and len(digits) == 11:
        return "+" + digits
    if digits.startswith("8") and len(digits) == 11:
        return "+7" + digits[1:]
    # fallback (don‚Äôt accept as valid phone elsewhere)
    return digits

def link_chat(identifier: str, chat_id: int):
    """Attach this ident to chat_id, but DO NOT unmap other idents.
    A chat can have both email and phone; /status will aggregate."""
    bundle = data_store.setdefault(identifier, {"items": {}, "orders": {}, "chat_id": chat_id})
    bundle["chat_id"] = chat_id
    save_data()

def idents_for_chat(chat_id: int) -> list[str]:
    """Return all identifiers (email/phone) mapped to this chat_id."""
    return [k for k, v in data_store.items() if v.get("chat_id") == chat_id]

def aggregate_status_for_chat(chat_id: int) -> dict:
    """Union items/orders across all idents linked to this chat."""
    items, orders = {}, {}
    for ident in idents_for_chat(chat_id):
        b = data_store.get(ident, {})
        items.update(b.get("items", {}))
        orders.update(b.get("orders", {}))
    return {"items": items, "orders": orders}

def build_status_lines(info: dict) -> list[str]:
    lines = []
    items = (info or {}).get("items", {})
    orders = (info or {}).get("orders", {})

    if items:
        lines.append("<b>üßæ Your selling items</b>")
        for rec_id, rec in items.items():
            name = html_escape(rec.get("name") or f"Item {rec_id}")
            status = html_escape(rec.get("status") or "Unknown")
            lines.append(f"‚Ä¢ {name} ‚Äî <b>{status}</b>")

    if orders:
        if lines:  # add a blank line between sections
            lines.append("")
        lines.append("<b>üõçÔ∏è Your orders</b>")
        for rec_id, rec in orders.items():
            item_name = html_escape(rec.get("item") or f"Order {rec_id}")
            status = html_escape(rec.get("status") or "Unknown")
            lines.append(f"‚Ä¢ {item_name} ‚Äî <b>{status}</b>")

    return lines

# -------- telegram (PTB v21) --------
app_tg = Application.builder().token(BOT_TOKEN).build()
bot    = Bot(token=BOT_TOKEN)

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    kb = [[KeyboardButton("üì± Share my phone", request_contact=True)]]
    await update.message.reply_text(
        WELCOME,
        reply_markup=ReplyKeyboardMarkup(kb, one_time_keyboard=True, resize_keyboard=True),
        parse_mode="Markdown"
    )

async def cmd_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Commands:\n"
        "/start ‚Äì link your email/phone\n"
        "/status ‚Äì show your item & order statuses"
    )

async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    aggr = aggregate_status_for_chat(chat_id)
    lines = build_status_lines(aggr)
    await (update.message.reply_html("\n".join(lines)) if lines else update.message.reply_text("No items or orders found yet."))

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = (update.message.text or "").strip()
    if is_email(txt):
        email = normalize_email(txt)
        link_chat(email, update.effective_chat.id)
        await update.message.reply_text(f"‚úÖ Email {email} linked. Send /status to see updates.")
        return
    if is_phone(txt):
        phone = normalize_phone(txt)
        link_chat(phone, update.effective_chat.id)
        await update.message.reply_text(f"‚úÖ Phone {phone} linked. Send /status to see updates.")
        return
    await update.message.reply_text("Please send a valid email (name@example.com) or phone (+7XXXXXXXXXX).")

async def handle_contact(update: Update, context: ContextTypes.DEFAULT_TYPE):
    phone_raw = update.message.contact.phone_number
    if not is_phone(phone_raw):
        await update.message.reply_text("That doesn‚Äôt look like a valid RU phone. Enter it like +7XXXXXXXXXX.")
        return
    phone = normalize_phone(phone_raw)
    link_chat(phone, update.effective_chat.id)
    await update.message.reply_text("‚úÖ Phone linked. Send /status to see updates.")

# register handlers
app_tg.add_handler(CommandHandler("start", cmd_start))
app_tg.add_handler(CommandHandler("help",  cmd_help))
app_tg.add_handler(CommandHandler("status", cmd_status))
app_tg.add_handler(MessageHandler(filters.CONTACT, handle_contact))
app_tg.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

# -------- flask (web) --------
app = Flask(__name__)

@app.get("/")
def root():
    return "ok"

@app.get("/health")
def health():
    return "ok"

def kv_find(data: dict, *needles: str):
    for k in data.keys():
        name = k.lower()
        if all(n in name for n in needles):
            return k
    return None

def upsert_from_payload(payload: dict):
    # explicit pick
    email_key = next((k for k in payload.keys() if k.lower() in ("email","e-mail","–ø–æ—á—Ç–∞")), None)
    phone_key = next((k for k in payload.keys() if k.lower() in ("phone","—Ç–µ–ª–µ—Ñ–æ–Ω")), None)

    ident = None
    if email_key and is_email(payload.get(email_key)):
        ident = normalize_email(payload[email_key])
    elif phone_key and is_phone(payload.get(phone_key)):
        ident = normalize_phone(payload[phone_key])
    if not ident:
        return None, None, None

    # status: prefer human-friendly Stage; otherwise status
    status = None
    for k in payload.keys():
        if k.strip().lower() == "stage":
            status = (payload.get(k) or "").strip()
            break
    if not status:
        status_key = next((k for k in payload.keys() if "status" in k.lower()), None)
        status = (payload.get(status_key) or "Submitted").strip() if status_key else "Submitted"

    # item/order fields
    item_key = next((k for k in payload.keys() if k.lower() in ("item","product","—Ç–æ–≤–∞—Ä","–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ","–Ω–∞–∑–≤–∞–Ω–∏–µ")), None)
    order_key = next((k for k in payload.keys() if k.lower() in ("order","orderid","–∑–∞–∫–∞–∑","–Ω–æ–º–µ—Ä","id")), None)

    item_name = (payload.get(item_key) or "").strip() if item_key else ""
    order_id  = (payload.get(order_key) or "").strip() if order_key else ""
    tranid    = (payload.get("tranid") or payload.get("leadid") or payload.get("leads_id") or "").strip()

    kind = "order" if (order_key and not item_key) else "item"
    rec_id = tranid or order_id or item_name or f"rec-{int(datetime.utcnow().timestamp())}"

    bundle = data_store.setdefault(ident, {"items": {}, "orders": {}})
    if kind == "item":
        rec = bundle["items"].setdefault(rec_id, {"name": item_name or f"Item {rec_id}", "status": "Submitted"})
        if item_name: rec["name"] = item_name
        rec["status"] = status
    else:
        rec = bundle["orders"].setdefault(rec_id, {"item": item_name or f"Order {rec_id}", "status": "Placed"})
        if item_name: rec["item"] = item_name
        rec["status"] = status
    save_data()
    return ident, kind, rec_id

# ---- Tilda webhook: secured by PATH token ----
# We register the route at /tilda_webhook/<AUTH_TOKEN> so there is no secret in query.
TILDA_PATH = f"/tilda_webhook/{AUTH_TOKEN}"

def tilda_webhook():
    # accept form or JSON
    payload = {}
    try:
        if request.form:
            payload = request.form.to_dict(flat=True)
        elif request.is_json:
            payload = request.get_json(force=True) or {}
    except Exception as e:
        logger.warning("tilda payload parse error: %s", e); payload = {}

    ident, kind, rec_id = upsert_from_payload(payload)
    if ident and kind and rec_id:
        bundle = data_store.get(ident, {})
        chat_id = bundle.get("chat_id")
        if chat_id:
            if kind == "item":
                rec = bundle["items"][rec_id]
                msg = f"üîî Update: Your item <b>{html_escape(rec.get('name'))}</b> is now <b>{html_escape(rec.get('status'))}</b>."
            else:
                rec = bundle["orders"][rec_id]
                msg = f"üîî Update: Your order <b>{html_escape(rec.get('item'))}</b> is now <b>{html_escape(rec.get('status'))}</b>."
            try:
                bot.send_message(chat_id, msg, parse_mode="HTML")
            except Exception as e:
                logger.error("send_message error: %s", e)
    return "ok"

# bind the path with token
app.add_url_rule(TILDA_PATH, view_func=tilda_webhook, methods=["POST"])

# ---- CSV import (admin) secured by path + Authorization header ----
CSV_EMAIL_KEYS   = ["email", "e-mail", "–ø–æ—á—Ç–∞"]
CSV_PHONE_KEYS   = ["phone", "—Ç–µ–ª–µ—Ñ–æ–Ω"]
CSV_STATUS_KEYS  = ["status", "—Å—Ç–∞—Ç—É—Å"]
CSV_ITEM_KEYS    = ["item", "product", "—Ç–æ–≤–∞—Ä", "–Ω–∞–∑–≤–∞–Ω–∏–µ", "–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ"]
CSV_ORDERID_KEYS = ["order", "orderid", "–∑–∞–∫–∞–∑", "id", "–Ω–æ–º–µ—Ä"]

def pick_key(row: dict, candidates: list[str]) -> str | None:
    lower = {k.lower(): k for k in row.keys()}
    for want in candidates:
        for lk, orig in lower.items():
            if want in lk:
                return orig
    return None

def check_auth_header(req) -> bool:
    return req.headers.get("Authorization", "") == f"Bearer {AUTH_TOKEN}"

def upsert_row(row: dict, kind: str, notify: bool):
    # ----- identify strictly by explicit columns -----
    keys = {k.lower(): k for k in row.keys()}
    k_email = next((keys[k] for k in keys if k in ("email","e-mail","–ø–æ—á—Ç–∞")), None)
    k_phone = next((keys[k] for k in keys if k in ("phone","—Ç–µ–ª–µ—Ñ–æ–Ω")), None)

    ident = None
    if k_email and is_email(row.get(k_email)):
        ident = normalize_email(row[k_email])
    elif k_phone and is_phone(row.get(k_phone)):
        ident = normalize_phone(row[k_phone])
    if not ident:
        return

    # ---------- find fields in this CSV row ----------
    k_status   = pick_key(row, CSV_STATUS_KEYS)  # common aliases like "status", "—Å—Ç–∞—Ç—É—Å"
    k_item     = pick_key(row, CSV_ITEM_KEYS)    # "item", "product", "—Ç–æ–≤–∞—Ä", ...
    k_orderid  = pick_key(row, CSV_ORDERID_KEYS) # "order", "orderid", "–∑–∞–∫–∞–∑", ...

    # Prefer human-readable Stage if present; otherwise fall back to status/statusid/etc.
    status = None
    for key in row.keys():
        lk = key.strip().lower()
        if lk == "stage":  # Tilda board column name (human text)
            status = (row[key] or "").strip()
            break
    if not status:
        status = (row.get(k_status) or "").strip() if k_status else ""
    if not status:
        # extra fallbacks that sometimes appear in Tilda exports
        status = (row.get("statusid") or row.get("pipeline") or row.get("pipeline_stage") or "").strip()
    if not status:
        status = "Submitted"

    # Item/Order display name:
    itemname = (row.get(k_item) or "").strip() if k_item else ""
    if not itemname:
        # Build from Brand + Size if present
        k_brand = pick_key(row, ["brand", "–±—Ä–µ–Ω–¥"])
        k_size  = pick_key(row, ["size", "—Ä–∞–∑–º–µ—Ä"])
        brand = (row.get(k_brand) or "").strip() if k_brand else ""
        size  = (row.get(k_size)  or "").strip() if k_size  else ""
        combo = " ".join([p for p in [brand, size] if p])
        itemname = combo if combo else None

    # Record ID: prefer explicit ids (tranid/order id), else item name, else timestamp
    tranid = (row.get("tranid") or row.get("leadid") or row.get("leads_id") or "").strip()
    order_id_val = (row.get(k_orderid) or "").strip() if k_orderid else ""
    rec_id = tranid or order_id_val or (itemname or "").strip() or f"rec-{int(datetime.utcnow().timestamp())}"

    # ---------- upsert into our store ----------
    bundle = data_store.setdefault(ident, {"items": {}, "orders": {}})
    if kind == "item":
        rec = bundle["items"].setdefault(rec_id, {"name": itemname or f"Item {rec_id}", "status": "Submitted"})
        if itemname:
            rec["name"] = itemname
        rec["status"] = status
    else:
        rec = bundle["orders"].setdefault(rec_id, {"item": itemname or f"Order {rec_id}", "status": "Placed"})
        if itemname:
            rec["item"] = itemname
        rec["status"] = status

    save_data()

    # ---------- optional notify ----------
    if notify and (chat_id := bundle.get("chat_id")):
        msg = (
            f"üîî Update: Your item <b>{html_escape(rec.get('name'))}</b> is now <b>{html_escape(status)}</b>."
            if kind == "item" else
            f"üîî Update: Your order <b>{html_escape(rec.get('item'))}</b> is now <b>{html_escape(status)}</b>."
        )
        try:
            bot.send_message(chat_id, msg, parse_mode="HTML")
        except Exception as e:
            logger.error("notify error: %s", e)

ADMIN_IMPORT_PATH = f"/admin/{ADMIN_PATH}/import_csv"

def admin_import_csv():
    if not check_auth_header(request):
        return "forbidden", 403
    kind = (request.args.get("type") or "").strip().lower()
    if kind not in {"item","order"}:
        return "bad type", 400

    # basic size guard (~10MB). For very large boards, split CSV and upload in parts.
    if "file" not in request.files:
        return "no file", 400
    f = request.files["file"]
    f.seek(0, 2); size = f.tell(); f.seek(0)
    if size > 10 * 1024 * 1024:
        return "file too large", 413

    try:
        raw = f.read()
        # try common encodings (handles BOM & Cyrillic)
        text = None
        for enc in ("utf-8-sig", "utf-8", "cp1251", "windows-1251", "latin-1"):
            try:
                text = raw.decode(enc)
                break
            except Exception:
                continue
        if text is None:
            return "decode error", 415

        # Auto-detect delimiter (comma, semicolon, tab); fallback to ; then ,
        sample = text[:4096]
        try:
            dialect = csv.Sniffer().sniff(sample, delimiters=[",",";","\t"])
            reader = csv.DictReader(io.StringIO(text), dialect=dialect)
        except Exception:
            try:
                reader = csv.DictReader(io.StringIO(text), delimiter=";")
            except Exception:
                reader = csv.DictReader(io.StringIO(text), delimiter=",")

        count = 0
        for row in reader:
            # skip rows that are completely empty
            if not isinstance(row, dict) or not any((v or "").strip() for v in row.values()):
                continue
            upsert_row(row, kind, notify=False)
            count += 1
        return f"ok,{count}"
    except Exception as e:
        # temporary debug ‚Äî helps us see what's wrong if any
        return f"error: {type(e).__name__}: {e}", 500

app.add_url_rule(ADMIN_IMPORT_PATH, view_func=admin_import_csv, methods=["POST"])

# -------- Peek / Search / Alias helpers (admin) --------
@app.get(f"/admin/{ADMIN_PATH}/peek")
def admin_peek():
    if not check_auth_header(request):
        return "forbidden", 403
    ident_raw = (request.args.get("ident") or "").strip()
    if not ident_raw:
        return "missing ident", 400

    ident = normalize_email(ident_raw) if "@" in ident_raw else normalize_phone(ident_raw)
    bundle = data_store.get(ident)
    if not bundle:
        return {"ident": ident, "found": False}, 200

    items = bundle.get("items", {})
    orders = bundle.get("orders", {})
    return {
        "ident": ident,
        "found": True,
        "chat_id": bundle.get("chat_id"),
        "counts": {"items": len(items), "orders": len(orders)},
        "samples": {
            "items": list(items.values())[:3],
            "orders": list(orders.values())[:3],
        }
    }, 200

@app.get(f"/admin/{ADMIN_PATH}/search")
def admin_search():
    if not check_auth_header(request):
        return "forbidden", 403
    q = (request.args.get("q") or "").strip().lower()
    out = []
    for k, v in data_store.items():
        if q in k.lower():
            out.append({
                "ident": k,
                "chat_id": v.get("chat_id"),
                "items": len(v.get("items", {})),
                "orders": len(v.get("orders", {}))
            })
            if len(out) >= 50:
                break
    return {"results": out}, 200

@app.post(f"/admin/{ADMIN_PATH}/alias")
def admin_alias():
    if not check_auth_header(request):
        return "forbidden", 403
    src_raw = (request.form.get("from") or "").strip()
    dst_raw = (request.form.get("to") or "").strip()
    if not src_raw or not dst_raw:
        return "missing params", 400

    def norm(x):
        return normalize_email(x) if "@" in x else normalize_phone(x)

    src = norm(src_raw)
    dst = norm(dst_raw)
    if src not in data_store:
        return {"moved": False, "reason": "source not found", "src": src}, 404

    dst_bundle = data_store.setdefault(dst, {"items": {}, "orders": {}})
    sb = data_store[src]
    dst_bundle["items"].update(sb.get("items", {}))
    dst_bundle["orders"].update(sb.get("orders", {}))
    if not dst_bundle.get("chat_id") and sb.get("chat_id"):
        dst_bundle["chat_id"] = sb.get("chat_id")

    del data_store[src]
    save_data()
    return {"moved": True, "from": src, "to": dst,
            "dst_counts": {"items": len(dst_bundle["items"]), "orders": len(dst_bundle["orders"])}}, 200

# -------- run (Flask in thread, bot in main) --------
def run_flask():
    logger.info("Flask starting‚Ä¶")
    app.run(host="0.0.0.0", port=PORT)

if __name__ == "__main__":
    # Start Flask in background
    threading.Thread(target=run_flask, daemon=True).start()

    # Start Telegram polling in MAIN thread (no asyncio.run here)
    logger.info("Starting Telegram polling‚Ä¶")
    app_tg.run_polling(allowed_updates=Update.ALL_TYPES)